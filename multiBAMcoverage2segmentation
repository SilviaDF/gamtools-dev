#! /usr/bin/Rscript
args <- commandArgs(TRUE)

usage = "multiBAMcoverage2segmentation [--significance 0.001] [--background_start 0] [--background_end 5] <INPUT> <OUTPUT>
  
  Required parameters:
  
  <INPUT>  - Input file (output from a call to multiBamCov)
  <OUTPUT> - Desired output file (same format as the input fie, yet with a 0=>not enriched / 1=> enriched encoding)
  
  Additional options:

  --significance        - Set the desired significance level (default: 0.001, must be in range 0-1)
  --background_start    - Minimal window count to fit background (default 0, must be integer)
  --background_end      - Maxiimal window count to fit background (default 5, must be integer)

  --two-step-estimation - Do the estimation twice removing all bins in the second estimation that are never found positive in any sample in the first
  
"

len = length(args);

if( (len < 2) || (len > 9) ){
    stop("Wrong input parameters\n\n", usage);
}

infile = args[len-1]
outfile = args[len]

if(file.access(infile, mode = 4)==-1){
    stop("input file does not exist or can't be read!\n\n", usage)
}
if(file.exists(outfile)){
    write("Warning: output file exists, will be overwritten.", stderr())
}

# Set defaults
background_from = 0;
background_to = 5;
significance = 0.001
do_two_step = FALSE

# Parameter handling
if(len>2){
   i = 1;
   while(i <= (len-2) ){
    if(args[i] == "--significance"){
	significance = as.numeric(args[i+1]);
	if(is.na(significance)){ stop("wrong parameter for --significance : \"", args[i+1], "\"\n\n", usage); }
	if((significance < 0) || (significance > 1)){ stop("--significance must be in range 0-1!\n\n", usage); }
	i=i+2
    } else if (args[i] == "--background_start"){
	background_from = as.integer(args[i+1]);
	if(is.na(background_from)){ stop("wrong parameter for --background_start : \"", args[i+1], "\"\n\n", usage); }
	if(background_from < 0){ stop("no negative values allowed for --background_start !\n\n", usage); }
	i=i+2
    } else if (args[i] == "--background_end"){
	background_to = as.integer(args[i+1]);
	if(is.na(background_to)){ stop("wrong parameter for --background_end : \"", args[i+1], "\"\n\n", usage); }
	i=i+2
    } else if (args[i] == "--two-step-estimation"){
	do_two_step = TRUE;
	i=i+1
    } else {
	stop("Unknown input parameter \"", args[i], "\"\n\n", usage);
    }
   }
}

suppressMessages(library(truncdist))
suppressMessages(library(fitdistrplus))

col.names = as.character(read.delim(infile, sep=" ", nrow=1, as.is=TRUE, header=FALSE)[1,][-1])
row.names = read.delim(pipe(paste("cut -f 1-3", infile)), skip=1, as.is=TRUE, header=FALSE)
row.names = paste(row.names[,1], "\t", row.names[,2], "-", row.names[,3], sep="")

mat = read.delim(infile, skip=1, as.is=TRUE, header=FALSE)[,c(1,2,3)*-1]
colnames(mat) = col.names
rownames(mat) = row.names

dtruncated_neg_binomial <- function(x, size, mu){ return(dtrunc(x, "nbinom", a=background_from-1, b=background_to+1, size=size, mu=mu)) }
ptruncated_neg_binomial <- function(x, size, mu){ return(ptrunc(x, "nbinom", a=background_from-1, b=background_to+1, size=size, mu=mu)) }
qtruncated_neg_binomial <- function(x, size, mu){ return(qtrunc(x, "nbinom", a=background_from-1, b=background_to+1, size=size, mu=mu)) }

get_significantly_enriched_internal = function(coverage, from, to, sig.threshold){
    eps <- sqrt(.Machine$double.eps)
    # The "start" values were averages from one segmentation
    f = fitdist(coverage[(coverage>=from)&(coverage<=to)], "truncated_neg_binomial", lower=c(eps,eps), start = c(size=1.85, mu=1.5))
    thresh = qnbinom(1-sig.threshold, size=f$estimate["size"], mu=f$estimate["mu"])
    ret = rep(0, length(coverage))
    ret[coverage>thresh] = 1
    return(ret)
}

get_significantly_enriched = function(coverage, samplename, from, to, sig.threshold){
    # This is a wrapper with error handling
    ret = tryCatch(get_significantly_enriched_internal(coverage, from, to, sig.threshold),
	error=function(e){ return(list(rep(0, length(coverage)), e))},
	warning=function(w){ return(list(get_significantly_enriched_internal(coverage, from, to, sig.threshold), w))}
    )
    # In case a list was returned either a warning or an error occured
    if(is.list(ret)){
	if(is(ret[[2]],"warning")){
	    write(paste("Warning for ", samplename, ": \"", paste(gsub("\n", "", ret[[2]]), sep=", "), "\" Results for this sample might be incorrect.", sep=""), stderr())
	} else {
	    write(paste("Error in ", samplename, ": \"", paste(gsub("\n", "", ret[[2]]), sep=", "), "\"No enriched bins assigned to this sample.", sep=""), stderr())
	}
	return(ret[[1]])
    } else {
	return(ret)
    }
}



results = sapply(1:ncol(mat), function(i){
    return(get_significantly_enriched(mat[,i], colnames(mat)[i], background_from, background_to, significance))
})
rownames(results) = rownames(mat)

if(do_two_step){
    always_zero = (rowSums(results)==0)
    results[!always_zero, ] = sapply(1:ncol(mat), function(i){
	return(get_significantly_enriched(mat[!always_zero,i], colnames(mat)[i], background_from, background_to, significance))
    })
}

write.table(t(c("window", colnames(results))), outfile, sep="\t", col.names=FALSE, row.names=FALSE, quote=FALSE)
write.table(results, outfile, sep="\t", col.names=FALSE, row.names=TRUE, quote=FALSE, append=TRUE)
